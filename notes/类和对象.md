# Cpp学习笔记 类和对象

## 一个完整的类的实现的实例

参照 《CPP Primer Plus》中的 stock 类。

### stock.h

```cpp
#ifndef STOCK_H
#define STOCK_H

#include <iostream>
#include <string>

class Stock
{
private:
    static 
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }  //内联函数

public:
    void acquire(const std::string& co, long n, double pr);
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show() const; // const成员函数，用于不更改对象中的值的函数。这样const对象才能调用这个函数
};

#endif
```

### stock.cpp
```cpp
#include <iostream>
#include <string>
#include "Stock.h"

void Stock::acquire(const std::string& co, long n, double pr) {
    company = co;
    if (n < 0) {
        std::cout << "Number of shares can't be negative; "
            << company << " shares set to 0.\n";
        shares = 0;
    }
    else {
        shares = n;
    }
    share_val = pr;
    set_tot();
}

void Stock::buy(long num, double price) {
    shares += num;
    share_val = price;
    set_tot();
}

void Stock::sell(long num, double price) {
    shares = (shares - num >= 0) ? shares - num : 0;
    share_val = price;
    set_tot();
}

void Stock::update(double price) {
    share_val = price;
    set_tot();
}

void Stock::show() const {
    std::cout << "Company: " << company
        << "  shares: " << shares << "\n"
        << "  Share Price: $" << share_val
        << "  Total Worth: $" << total_val << std::endl;
}
```

## main.cpp

```cpp
#include <string>
#include "Stock.h"

int main() {
    Stock Haymax("Haymax", 0, 0);
    Haymax.buy(10, 100);
    Haymax.show();
    return 0;
}
// 也可以使用  Stock Haymax {"Haymax", 0, 0}; 只要参数列表和一种构造函数的参数列表一样就行
```

## 类成员常量

在声明类的时候，如果只用 `const` 限定一个变量的话，这个变量只是对**某一个具体的对象**是常量不可改变的。这个变量只能在对象实例化的时候初始化。比如：
```cpp
class A{
private:
    const int SIZE = 10;
    int my_array[SIZE]; // Error, SIZE对于这里不是一个const
public:
    A();
    ~A();
};
```

正确的写法应该是利用 `static` 关键字进行限定。此时该变量将存储在 静态存储区，进而不受对象实例化和对象的生命周期的影响

```cpp
class A{
private:
    static const int SIZE = 10;
    int my_array[SIZE]; // Error, SIZE对于这里不是一个const
};
```

## 运算符重载，友元函数

只需要把要重载的运算符放在 `operator` 关键字的后面就可以。

友元函数常用于二元运算符重载

### 函数原型
```cpp
// 成员函数中重载
class Time{
private:
    int hours=0;
    int minutes=0;
public:
    // 成员函数，对象本身在操作数的左边。
    Time operator*{const double mult} const;
    // 非成员函数中重载二元运算符，因此无法操作私有成员，声明为友元
    friend Time operator*(const double mult, const Time & t);
    friend std::ostream & operator<<(std::ostream & os, const Time & t);
}
```

### 函数定义
```cpp
Time Time::operator*(const double mult)const
{
    Time result;
    long totalMinutes = hours * nult * 60 + minutes * 60;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}

Time operator*(const double mult, const Time & t)
{
    return t * m;   //这里就直接调用重载了
}

std::ostream & operator<<(std::ostream & os, const Time & t)
{
    os << t.hours << " hours, "<< t.minutes << " minutes";
    return os;
}
```

## 强制类型转换

一个类的强制类型转换，可以由只有一个参数的构造函数来进行，或者多个参数但是其余的给定了默认值。  

利用关键字 `explicit` 可以屏蔽隐式的类型转换

### 类的原型
```cpp
class stoneWt
{
private:
    static const Lbs_per_stn = 14;
    int stone;
    double pds_left;
    double pounds;
public:
    stoneWt(double lbs);    // 强制类型转换
    stoneWt(int stn, double lbs);
    stoneWt();
    ~stoneWt();
}
```

### 类的声明
```cpp
stoneWt::stoneWt(double lbs)
{
    stone = int (lbs) / Lbs_per_stn;
    pds_left = int (lbs) % Lbs_per_stn;
    pounds = lbs;
}
```
